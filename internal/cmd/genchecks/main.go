//go:generate go run .
package main

import (
	"fmt"
	"os"
	"path/filepath"

	"gopkg.in/yaml.v3"
)

type Interface struct {
	Name  string   `yaml:"name"`
	Impls []string `yaml:"impls"`
}

type FileConfig struct {
	Output     string      `yaml:"output"`
	Package    string      `yaml:"package"`
	Interfaces []Interface `yaml:"interfaces"`
}

type Config struct {
	Files []FileConfig `yaml:"files"`
}

func main() {
	data, err := os.ReadFile("genchecks.yml")
	if err != nil {
		panic(fmt.Errorf("read gen .yml fail: %s", err.Error()))
	}

	var cfg Config
	if err := yaml.Unmarshal(data, &cfg); err != nil {
		panic(fmt.Errorf("unmarshal gen .yml fail: %s", err.Error()))
	}

	// 遍歷每個檔案設定
	for _, file := range cfg.Files {
		if err := os.MkdirAll(filepath.Dir(file.Output), os.ModePerm); err != nil {
			panic(fmt.Errorf("os.MkdirAll fail: %w", err))
		}

		f, err := os.Create(file.Output)
		if err != nil {
			panic(fmt.Errorf("os.Create fail: %w", err))
		}

		defer f.Close()

		content := fmt.Sprintf("package %s\n\n// Code generated by gen-checks; DO NOT EDIT.\n// Be sure to explicitly check the interfaces you will use at compile time\n\nvar (\n", file.Package)

		for _, iface := range file.Interfaces {
			for _, impl := range iface.Impls {
				content += fmt.Sprintf("    _ %s = (*%s)(nil)\n", iface.Name, impl)
			}
			content += "\n"
		}
		content += ")\n"

		if _, err := f.WriteString(content); err != nil {
			panic(fmt.Errorf("f.WriteString(content) fail: %w", err))
		}

		fmt.Printf("[%s] Generated: %v", file.Package, file.Output)
	}
}
